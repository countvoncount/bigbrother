#!/usr/bin/env python
## -*- coding: utf-8 -*-

import os,sys

SOPHIE_BASE = os.environ.get('VURVE_SOPHIE_BASE','/Users/tiago/vurve/code/sophie');
print SOPHIE_BASE
sys.path.append(SOPHIE_BASE)


from sqlalchemy import create_engine,func,and_,asc
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column,Integer,Unicode,DateTime,ForeignKey,Boolean
from datetime import timedelta,datetime,date
from sophie.lib.connectors.vurve.db.merchant_db_orm import StoreAccount
from sophie.lib.connectors.vurve.db.pixel_db_orm import Click
from sophie.lib.bigbrother.clicksession_db_orm import  ClickSession, SessionMkg, Histogram
import sophie.lib.bigbrother.clicksession_db as clickdb
import logging
import yaml
import array
import paste,pickle

#Load the logger 
log = logging.getLogger(__name__)
log.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
log.addHandler(ch)

#Load the configurations for the databases
config = yaml.load(open(SOPHIE_BASE+'/sophie/lib/bigbrother/conifg.yml'))

#This variable defines the largest session we want to consider
#The initial observation of the data indicates that 2000 seconds is a good value for it
#It should not be too large as this will impact the queries
_maxUsefulLength = 2000


#Generates a histogram of all sessions that start between date and date+duration and that have trafic qualification higher than qualification_certainty_lowerbound
def CreateSessionDurationHistogram(date=datetime.today(),duration=24*60*60,qualification_certainty_lowerbound=0):
    #The duration of the histograms in seconds                 
    hist = clickdb.QuerySessionCountsInTimeStartWindow(date,date+timedelta(seconds=duration),_maxUsefulLength,qualification_certainty_lowerbound)
    #Initialize an array with the data.
    #It is just wasteful to make a dictionary for a sequential array
    arr_hist = array.array('I',(0,)*_maxUsefulLength)
    ormHistogram = Histogram()

    max = 0;
    
    #Save the queried data in the array
    for h in hist:
        arr_hist[h[0]]=h[1];
        #XXX:remove
        if h[1] > max:
            max = h[1]

    print "Largest entry {0}".format(max)

    ormHistogram.date = date
    ormHistogram.duration = duration
    ormHistogram.set = 0 #Indicates it is over all stores
    ormHistogram.histogram = arr_hist #This object gets pickled in the database
    ormHistogram.qualification_certainty_lb = qualification_certainty_lowerbound
    return ormHistogram


#Generate histograms up to today and persist them in the histogram table
#if qualified is true it will selec only sessions which have fully qualified traffic.
def GenerateDailyHistogramsUpToToday(qualified=False):
    if qualified:
        qcl = 1
    else:
        qcl = 0

    #Get the last histogram that satisfies the criteria
    hist = clickdb.QueryLatestHistogramByDuration(duration=60*60*24,set=0,qualification_certainty_lowerbound=qcl)
    
    #If there are no histograms in the database start from the live view up time
    if hist is None:
        startDate = clickdb._liveViewUp.date()
    else:
    #If there are some then start the next day of the latest
        startDate = hist.date.date() + timedelta(days=1)
    
    endDate = datetime.utcnow().date() #An easy way to get the first second of today
    
    if qualified:
        log.info("will generate day long histograms for qualified trafic over all stores from {0} to {1}".format(startDate,endDate))
    else:
         log.info("will generate day long histograms for all trafic over all stores from {0} to {1}".format(startDate,endDate))
    actDate = startDate

    #iterate up to today
    while actDate<endDate:
        hist = CreateSessionDurationHistogram(actDate,60*60*24,qualification_certainty_lowerbound=qcl)
        clickdb.PersistHistogram(hist)
        actDate = actDate + timedelta(days=1)
        log.info("Created histogram for {0}".format(actDate))


#This function returns the histogram generated by aggregating the daily histograms from [startDate to endDate)
def GetHistogramForDateRange(date_min,date_max,qualified=False):
    utcNowDateTime = datetime.utcnow()
    utcNowDate = datetime(utcNowDateTime.year,utcNowDateTime.month,utcNowDateTime.day)

    if date_max > utcNowDate:
        log.error("Histogram requested with start date later than today, {0}".format(date_min))
    if date_min > utcNowDate:
        log.error("Histogram requested with end date later than today, {0}".format(date_max))
     
    if qualified:
        qcl = 1
        print "Will query qualified"
    else:
        qcl = 0

    #Query all the day histograms from start date to end date, with day long duration
    q = clickdb.QueryHistogramsForDateRange(date_min,date_max,duration=60*60*24,qualification_certainty_lowerbound=qcl)
    #Yes use an efficient array to accumulate the values
    a = array.array('I',(0,)*_maxUsefulLength)

    if q.count() !=0:
        for h in q:
            ah = h.histogram
            for i in range(_maxUsefulLength):
                a[i]+=ah[i]
    else:
       log.debug("Query produced no stored histograms")
    return list(a)
    

if __name__=="__main__":
    GenerateDailyHistogramsUpToToday()
    GenerateDailyHistogramsUpToToday(qualified=True)
    
